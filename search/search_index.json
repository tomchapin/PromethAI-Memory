{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"cognee","text":""},{"location":"#make-data-processing-for-llms-easy","title":"Make data processing for LLMs easy","text":"<p>Open-source framework for creating knowledge graphs and data models for LLMs.</p> <p></p> <p></p> <p>cognee makes it easy to reliably enrich data for Large Language Models (LLMs) like GPT-3.5, GPT-4, GPT-4-Vision, including in the future the open source models like Mistral/Mixtral from Together, Anyscale, Ollama, and llama-cpp-python.</p> <p>By leveraging various tools like graph databases, function calling, tool calling and Pydantic; cognee stands out for its aim to emulate human memory for LLM apps and frameworks. </p> <p>We leverage Neo4j to do the heavy lifting and dlt to load the data, and we've built a simple, easy-to-use API on top of it by helping you manage your context</p>"},{"location":"#getting-started","title":"Getting Started","text":"<p><pre><code>pip install -U cognee[\"weaviate\"]\n</code></pre> Set OpenAI API Key as an environment variable</p> <pre><code>import os\n\n# Setting an environment variable\nos.environ['OPENAI_API_KEY'] = ''\n</code></pre> <p>Import cognee and start using it</p> <pre><code>import cognee\nfrom os import listdir, path\nfrom cognee import add\n\ndata_path = path.abspath(\".data\")\n\nresults = await add(data_path, \"izmene\")\nfor result in results:\n    print(result)\n</code></pre> <p>Run the following command to see the graph.  Make sure to add your Graphistry credentials to .env beforehand</p> <pre><code>from cognee.utils import render_graph\n\ngraph = await cognee.cognify(\"izmene\")\ngraph_url = await render_graph(graph, graph_type = \"networkx\")\nprint(graph_url)\n</code></pre> <p>Search the graph for a piece of information</p> <pre><code>from cognee import search\nfrom cognee.api.v1.search.search import SearchType\nquery_params = {\n    SearchType.SIMILARITY: {'query': 'your search query here'}\n}\nout = await search(graph, query_params)\n</code></pre>"},{"location":"#why-use-cognee","title":"Why use cognee?","text":"<p>The question of using cognee is fundamentally a question of why to structure data inputs and outputs for your llm workflows.</p> <ol> <li> <p>Cost effective \u2014 cognee extends the capabilities of your LLMs without the need for expensive data processing tools.</p> </li> <li> <p>Self contained \u2014 cognee runs as a library and is simple to use</p> </li> <li> <p>Interpretable \u2014 Navigate graphs instead of embeddings to understand your data.</p> </li> <li> <p>User Guided cognee lets you control your input and provide your own Pydantic data models </p> </li> </ol>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the terms of the MIT License.</p>"},{"location":"research/","title":"Research","text":"<p>The page is dedicated to collecting all research that was collected in the past one year from various sources.</p> <p>This is not an exhaustive list, and any PRs would be welcome</p>"},{"location":"research/#research-papers","title":"Research Papers","text":"<ul> <li>[2024/03/24] Compound AI systems</li> <li>[2015/07/30] Multilayer Network of Language</li> <li>[2023/12/12]  Dense X Retrieval: What Retrieval Granularity Should We Use?</li> <li>[2024/01/05] Retrieval-Augmented Generation for Large Language Models: A Survey</li> <li>[2022/10/20]  Cognitive modelling with multilayer networks: Insights, advancements and future challenges</li> <li>[2023/09/20] CoAla framework and relevant literature literature</li> <li>[2023/06/09]\u00a0Mind2Web: Towards a Generalist Agent for the Web, Xiang Deng, et al.\u00a0[code] [demo]</li> <li>[2023/06/28] AI Agents in Langchain https://docs.google.com/presentation/d/1L_CHsg26sDxPmKj285Ob5T2xsAUejBlfiGQSnsSHTk0/edit#slide=id.g254e571859c_0_164</li> <li>[2023/06/27] Agent infra https://lilianweng.github.io/posts/2023-06-23-agent/</li> <li>[2023/06/05]\u00a0Orca: Progressive Learning from Complex Explanation Traces of GPT-4, Subhabrata Mukherjee et al.</li> <li>[2023/05/25]\u00a0\ud83d\udcdaVoyager: An Open-Ended Embodied Agent with Large Language Models, Guanzhi Wang, et al.\u00a0[code] [website], Shishir G. Patil, et al.</li> <li>[2023/05/24]\u00a0\ud83d\udcdaGorilla: Gorilla: Large Language Model Connected with Massive APIs</li> <li>[2023/05/17]\u00a0\ud83d\udcdaTree of Thoughts: Deliberate Problem Solving with Large Language Models, Shunyu Yao, et al.[code] [code-orig]</li> <li>[2023/05/12]\u00a0\ud83d\udcdaMEGABYTE: Predicting Million-byte Sequences with Multiscale Transformers, Lili Yu, et al.</li> <li>[2023/05/09]\u00a0\ud83d\udcdaFrugalGPT: How to Use Large Language Models While Reducing Cost and Improving Performance, Lingjiao Chen, et al.</li> <li>[2023/05/01]\u00a0\ud83d\udcdaLearning to Reason and Memorize with Self-Notes, Jack Lanchantin, et al.</li> <li>[2023/04/24]\u00a0\ud83d\udcdaWizardLM: Empowering Large Language Models to Follow Complex Instructions, Can Xu, et al.</li> <li>[2023/04/22]\u00a0\ud83d\udcdaLLM+P: Empowering Large Language Models with Optimal Planning Proficiency, Bo Liu, et al.</li> <li>[2023/04/07]\u00a0\ud83d\udcdaGenerative Agents: Interactive Simulacra of Human Behavior, Joon Sung Park, et al.\u00a0[code]</li> <li>[2023/03/30]\u00a0Self-Refine: Iterative Refinement with Self-Feedback, Aman Madaan, et al.[code]</li> <li>[2023/03/30]\u00a0HuggingGPT: Solving AI Tasks with ChatGPT and its Friends in HuggingFace, Yongliang Shen, et al.\u00a0[code] [demo]</li> <li>[2023/03/20]\u00a0Reflexion: Language Agents with Verbal Reinforcement Learning, Noah Shinn , et al.\u00a0[code]</li> <li>[2023/02/23]\u00a0\ud83d\udcdaNot what you've signed up for: Compromising Real-World LLM-Integrated Applications with Indirect Prompt Injection, Sahar Abdelnab, et al.</li> <li>[2023/02/09]\u00a0\ud83d\udcdaToolformer: Language Models Can Teach Themselves to Use Tools, Timo Schick, et al.\u00a0[code]</li> <li>[2022/12/12]\u00a0\ud83d\udcdaLMQL: Prompting Is Programming: A Query Language for Large Language Models, Luca Beurer-Kellner, et al.</li> <li>[2022/10/06]\u00a0ReAct: Synergizing Reasoning and Acting in Language Models, Shunyu Yao, et al.\u00a0[code]</li> <li>[2022/07/12]\u00a0\ud83d\udcdaInner Monologue: Embodied Reasoning through Planning with Language Models, Wenlong Huang, et al.\u00a0[demo]</li> <li>[2022/04/04]\u00a0Do As I Can, Not As I Say: Grounding Language in Robotic Affordances, Michael Ahn, e al.\u00a0[demo]</li> <li>[2021/12/17]\u00a0WebGPT: Browser-assisted question-answering with human feedback, Reiichiro Nakano, et al.</li> <li>[2021/06/17]\u00a0\ud83d\udcdaLoRA: Low-Rank Adaptation of Large Language Models, Edward J. Hu, et al.</li> <li>[2023/04/03] Generative Agents</li> <li>[2023/05/17] Three of thought: Deliberate Problem Solving with Large Language Models</li> </ul>"},{"location":"research/#blog-articles","title":"Blog Articles","text":"<ul> <li>[2023/04/29]\u00a0AUTO-GPT: UNLEASHING THE POWER OF AUTONOMOUS AI AGENTS\u00a0By Akash Takyar</li> <li>[2023/04/20]\u00a0Conscious Machines: Experiments, Theory, and Implementations(Chinese)\u00a0By Jiang Zhang</li> <li>[2023/04/18]\u00a0Autonomous Agents &amp; Agent Simulations\u00a0By Langchain</li> <li>[2023/04/16]\u00a04 Autonomous AI Agents you need to know\u00a0By Sophia Yang</li> <li>[2023/03/31]\u00a0ChatGPT that learns to use tools\u00a0By Haojie Pan</li> </ul>"},{"location":"research/#talks","title":"Talks","text":"<ul> <li>[2023/06/05]\u00a0Two Paths to Intelligence\u00a0by Geoffrey Hinton</li> <li>[2023/05/24]\u00a0State of GPT\u00a0by Andrej Karpathy | OpenAI</li> <li>[2024/03/15] Podcast on AI, Memory by Bill Gurley</li> </ul>"},{"location":"why/","title":"Why use cognee?","text":"<p>LLMs don't have a semantic layer, and they don't have a way to understand the data they are processing. This is where cognee comes in.  We let you define logical structures for your data and then use these structures to guide the LLMs to process the data in a way that makes sense to you.</p> Why use cognee? <p>Its hard to answer the question of why use cognee without answering why you need thin LLM frameworks in the first place.:</p> <ul> <li>Cost effective \u2014 cognee extends the capabilities of your LLMs without the need for expensive data processing tools.</li> <li>Self contained \u2014 cognee runs as a library and is simple to use</li> <li>Easy to use \u2014 cognee is simple to use and can be used by anyone with a basic understanding of Python</li> <li>Flexible \u2014 cognee can be used to structure data in any way you want, and can be used to structure data in any way you want. We rely on the work done by Pydantic and are inspired by the Instructor library, which is a simple way to structure data for LLMs.</li> </ul>"},{"location":"why/#bring-your-own-data-model","title":"Bring your own data model","text":"<p>If you are building an AI vertical, most of the time you will have a specific data model that you want to use. Cognee lets you bring your own data model and use it to structure your data in a way that makes sense to you.</p>"},{"location":"why/#data-processing","title":"Data processing","text":"<p>With dlt you can avoid all the boilerplate code that comes with data processing. We let you define logical structures for your data and then use these structures, deduplicated, incremental and replayable</p>"},{"location":"blog/","title":"Welcome to the cognee blog","text":"<p>The goal of the blog is to discuss broader topics around the cognee project, including the motivation behind the project, the technical details, and the future of the project.</p>"},{"location":"blog/#towards-production-pipelines-step-by-step","title":"Towards production pipelines step by step","text":"<ol> <li>From demo to production 1</li> <li>From demo to production 2</li> <li>From demo to production 3</li> <li>From demo to production 4</li> <li>Cognee - library release</li> </ol>"},{"location":"blog/posts/cognee-library-release/","title":"Cognee - library release","text":""},{"location":"blog/posts/cognee-library-release/#preface","title":"Preface","text":"<p>In a series of posts we explored issues with RAGs and the way we can build new infrastructure stack for the world of agent networks.</p> <p>To borrow the phrase Microsoft used, to restate the problem: </p> <ul> <li>Baseline RAG performs poorly when asked to understand summarized semantic concepts holistically over large data collections or even singular large documents.</li> </ul> <p>In the previous blog post we explained how developing a data platform and a memory layer for LLMs was one of our core aims.</p> <p>To do that more effectively we turned cognee into a python library in order to make it easier to use and get inspiration from the OSS community. </p>"},{"location":"blog/posts/cognee-library-release/#improved-memory-architecture","title":"Improved memory architecture","text":"<p>With the integration of Keepi.ai, we encountered several challenges that made us reassess our strategy. Among the issues we\u2019ve identified were:</p> <ul> <li> <p>The decomposition of user prompts into interconnected elements proved overly granular, leading to data management difficulties on load and retrieval.</p> </li> <li> <p>A recurring problem was the near-identical decomposition pattern for similar messages, which resulted in content duplication and an enlarged user graph. Our takeaway was that words and their interrelations represent only a fragment of the broader picture. We need to be able to guide the set of logical connections and make the system dynamic so that the data models can be adapted and adjusted to each particular use-case. What works for e-commerce transaction handling might not work for an AI vertical creating power point slides.</p> </li> <li> <p>The data model, encompassing Long-Term, Short-Term, and Buffer memory, proved both limited in scope and rigid, lacking the versatility to accommodate diverse applications and use cases. Just collecting all elements from all memories seemed naive, while getting certain nodes with classifiers did not add enough value.</p> </li> <li> <p>The retrieval of the entire buffer highlighted the need for improved buffer content management and a more adaptable buffer structure. We conceptualized the buffer as the analogue of human working memory, and recognize the need to better manage the stored data.</p> </li> </ul> <p>Moving forward, we have adopted several new strategies, features, and design principles:</p>"},{"location":"blog/posts/cognee-library-release/#propositions","title":"Propositions:","text":"<p>Defined as atomic expressions within a text, each proposition encapsulates a unique factoid, conveyed in a succinct, standalone natural language format. We employ Large Language Models (LLMs) to break down text into propositions and link them, forming graphs with propositions as nodes and their connections as edges.  For example,  \"Grass is green\", and \"2 + 5 = 5\"  are propositions. The first proposition has the truth value of \"true\" and the second \"false\".  The inspiration was found in the following paper: https://arxiv.org/pdf/2312.06648.pdf</p>"},{"location":"blog/posts/cognee-library-release/#multilayer-graph-network","title":"Multilayer Graph Network:","text":"<p>A cognitive multilayer networks is both a quantitative and interpretive framework for exploring the mental lexicon, the intricate cognitive system that stores information about known words/concepts.</p> <p>Mental lexicon is component of the human language faculty that contains information regarding the composition of words.</p> <p>Utilizing LLMs, we construct layers within the multilayer network to house propositions and their interrelations, enabling the interconnection of different semantic layers and the cross-layer linking of propositions. This facilitates both the segmentation and accurate retrieval of information.</p> <p>For example, if \"John Doe\" authored two New York Times cooking articles, we could extract an \"ingredients\" layer when needed, while also easily accessing all articles by \"John Doe\".</p> <p>We used concepts from psycholinguistics described here: https://arxiv.org/abs/1507.08539</p>"},{"location":"blog/posts/cognee-library-release/#data-loader","title":"Data Loader:","text":"<p>It\u2019s vital that we address the technical challenges associated with Retrieval-Augmented Generation (RAG), such as metadata management, context retrieval, knowledge sanitization, and data enrichment.</p> <p>The solution lies in a dependable data pipeline capable of efficiently and scalably preparing and loading data in various formats from a range of different sources. For this purpose, we can use 'dlt' as our data loader, gaining access to over 28 supported data sources.</p> <p>To enhance the Pythonic interface, we streamlined the use of cognee into three primary methods. Users can now execute the following steps:</p> <ul> <li>cognee.add(data): This method is used to input and normalize the data. It ensures the data is in the correct format and ready for further processing.</li> <li>cognee.cognify(): This function constructs a multilayer network of propositions, organizing the data into an interconnected, semantic structure that facilitates complex analysis and retrieval.</li> <li>cognee.search(query, method='default'): The search method enables the user to locate specific nodes, vectors, or generate summaries within the dataset, based on the provided query and chosen search method. We employ a combination of search approaches, each one relying on the technology implemented by vector datastores and graph stores.</li> </ul>"},{"location":"blog/posts/cognee-library-release/#integration-and-workflow","title":"Integration and Workflow","text":"<p>The integration of these three components allows for a cohesive and efficient workflow:</p> <p>Data Input and Normalization: </p> <p>Initially, Cognee.add is employed to input the data. During this stage, a dlt loader operates behind the scenes to process and store the data, assigning a unique dataset ID for tracking and retrieval purposes. This ensures the data is properly formatted and normalized, laying a solid foundation for the subsequent steps.</p> <p>Creation of Multilayer Network: </p> <p>Following the data normalization, Cognee.cognify takes the stage, constructing a multilayer network from the propositions derived from the input data. The network is created using LLM as a judge approach, with specific prompt that ask for creating of a set of relationships. This approach results in a set of layers and relationships that represent the document. </p> <p>Data Retrieval and Analysis</p> <p>The final step involves Cognee.search, where the user can query the constructed network to find specific information, analyze patterns, or extract summaries. The flexibility of the search function allows to search for content labels, summaries, nodes and also be able to retrieve data via similarity search. We also enable a combination of methods, which leads to getting benefits of different search approaches. </p>"},{"location":"blog/posts/cognee-library-release/#whats-next","title":"What\u2019s next","text":"<p>We're diligently developing our upcoming features, with key objectives including:</p> <ol> <li>Adding audio and image support</li> <li>Improving search</li> <li>Adding evals</li> <li>Adding local models</li> <li>Adding dspy</li> </ol> <p>To keep up with the progress, explore our implementation on GitHub and, if you find it valuable, consider starring it to show your support.</p>"},{"location":"blog/posts/from-demo-to-production-1/","title":"Going beyond Langchain + Weaviate and towards a production ready modern data platform","text":"","tags":["pydantic","langchain","llm","openai","functions","pdfs"]},{"location":"blog/posts/from-demo-to-production-1/#table-of-contents","title":"Table of Contents","text":"","tags":["pydantic","langchain","llm","openai","functions","pdfs"]},{"location":"blog/posts/from-demo-to-production-1/#1-introduction-the-current-generative-ai-landscape","title":"1. Introduction: The Current Generative AI Landscape","text":"","tags":["pydantic","langchain","llm","openai","functions","pdfs"]},{"location":"blog/posts/from-demo-to-production-1/#11-a-brief-overview","title":"1.1. A brief overview","text":"<p>Browsing the largest AI platform directory available at the moment, we can observe around 7,000 new, mostly semi-finished AI projects \u2014 projects whose development is fueled by recent improvements in foundation models and open-source community contributions.</p> <p>Decades of technological advancements have led to small teams being able to do in 2023 what in 2015 required a team of dozens.</p> <p>Yet, the AI apps currently being pushed out still mostly feel and perform like demos.</p> <p>It seems it has never been easier to create a startup, build an AI app, go to market\u2026 and fail.</p> <p>The consensus is, nevertheless, that the AI space is the place to be in 2023.</p> <p>\u201cThe AI Engineer [...] will likely be the highest-demand engineering job of the [coming] decade.\u201d </p> <p>Swyx</p> <p>The stellar rise of AI engineering as a profession is, perhaps, signaling the need for a unified solution that is not yet there \u2014 a platform that is, in its essence, a Large Language Model (LLM), which could be employed as a powerful general problem solver.</p> <p>To address this issue, dlthub and prometh.ai will collaborate on productionizing a common use-case, PDF processing, progressing step by step. We will use LLMs, AI frameworks, and services, refining the code until we attain a clearer understanding of what a modern LLM architecture stack might entail.</p> <p>You can find the code in the PromethAI-Memory repository</p>","tags":["pydantic","langchain","llm","openai","functions","pdfs"]},{"location":"blog/posts/from-demo-to-production-1/#12-the-problem-of-putting-code-to-production","title":"1.2. The problem of putting code to production","text":"<p>Despite all the AI startup hype, there\u2019s a glaring issue lurking right under the surface: foundation models do not have production-ready data infrastructure by default</p> <p>Everyone seems to be building simple tools, like \u201cYour Sales Agent\u201d or \u201cYour HR helper,\u201d on top of OpenAI \u2014 a so-called\u00a0 \u201cThin Wrapper\u201d \u2014 and selling them as services.</p> <p>Our intention, however, is not to merely capitalize on this nascent industry \u2014 it\u2019s to use a new technology to catalyze a true digital paradigm shift\u00a0 \u2014 to paraphrase investor Marc Andreessen, content of the new medium as the content of the previous medium.</p> <p>What Andreessen meant by this is that each new medium for sharing information must encapsulate the content of the prior medium. For example, the internet encapsulates all books, movies, pictures, and stories from previous mediums.</p> <p>After a unified AI solution is created, only then will AI agents be able to proactively and competently operate the browsers, apps, and devices we operate by ourselves today.</p> <p>Intelligent agents in AI are programs capable of perceiving their environment, acting autonomously in order to achieve goals, and may improve their performance by learning or acquiring knowledge.</p> <p>The reality is that we now have a set of data platforms and AI agents that are becoming available to the general public, whose content and methods were previously inaccessible to anyone not privy to the tech-heavy languages of data scientists and engineers.</p> <p>As engineering tools move toward the mainstream, they need to become more intuitive and user friendly, while hiding their complexity with a set of background solutions.</p> <p>Fundamentally, the issue of \u201cThin wrappers\u201d is not an issue of bad products, but an issue of a lack of robust enough data engineering methods coupled with the general difficulties that come with creating production-ready code that relies on robust data platforms in a new space. </p> <p>The current lack of production-ready data systems for LLMs and AI Agents opens up a gap we want to fill\u00a0 by introducing robust data engineering practices to solve this issue.</p> <p>In this series of texts, our aim will thus be to explore what would constitute:</p> <ol> <li>Proper data engineering methods for LLMs</li> <li>A production-ready generative AI data platform that unlocks AI assistants/Agent Networks</li> </ol> <p>Each of the coming blog posts will be followed by Python code, to demonstrate the progress made toward building a modern AI data platform, raise important questions, and facilitate an open-source collaboration.</p> <p>Let\u2019s start by setting an attainable goal. As an example, let\u2019s conceptualize a production-ready process that can analyze and process hundreds of PDFs for hundreds of users.</p>  \ud83d\udca1 As a user, I want an AI Data Platform to enable me to extract, organize, and summarize data from PDF invoices so that it's seamlessly updated in the database and available for further processing.   <p>Imagine you're a developer, and you've got a stack of digital invoices in PDF format from various vendors. These PDFs are not just simple text files; they contain logos, varying fonts, perhaps some tables, and even handwritten notes or signatures.</p> <p>Your goal? To extract relevant information, such as vendor names, invoice dates, total amounts, and line-item details, among others.</p> <p>This task of analyzing PDFs may help us understand and define what a production-ready AI data platform entails. To perform the task, we\u2019ll be drawing a parallel between Data Engineering concepts and those from Cognitive Sciences which tap into our understanding of how human memory works \u2014 this should provide the baseline for the evaluation of the POCs in this post.</p> <p>We assume that Agent Networks of the future would resemble groups of humans with their own memory and unique contexts, all working and contributing toward a set of common objectives.</p> <p>In our example of data extraction from PDFs \u2014 a modern enterprise may have hundreds of thousands, if not millions of such documents stored in different places, with many people hired to make sense of them.</p> <p>This data is considered unstructured \u2014 you cannot handle it easily with current data engineering practices and database technology. The task to structure it is difficult and, to this day, has always needed to be performed manually.</p> <p>With the advent of Agent Networks, which mimic human cognitive abilities, we could start realistically structuring this kind of information at scale. As this is still data processing \u2014 an engineering task \u2014 we need to combine those two approaches.</p> <p>From an engineering standpoint, the next generation Data Platform needs to be built with the following in mind:</p> <ul> <li>We need to give Agents access to the data at scale.</li> <li>We need our Agents to operate like human minds so we need to provide them with tools to execute tasks and various types of memory for reasoning</li> <li>We need to keep the systems under control, meaning that we apply good engineering practices to the whole system</li> <li>We need to be able to test, sandbox, and roll back what Agents do and we need to observe them and log every action</li> </ul> <p>In order to conceptualize a new model of data structure and relationships that transcends the traditional Data Warehousing approach, we can start perceiving procedural steps in Agent execution flows as thoughts and interpreting them through the prism of human cognitive processes such as the functioning of our memory system and its memory components.</p> <p>Human memory can be divided into several distinct categories:</p> <ul> <li>Sensory Memory (SM) \u2192 Very short term (15-30s) memory storage unit receiving information from our senses.</li> <li>Short Term Memory (STM) \u2192 Short term memory that processes the information, and coordinates work based on information provided.</li> <li>Long-Term Memory (LTM) \u2192 Stores information long term, and retrieves what it needs for daily life.</li> </ul> <p>The general structure of human memory. Note that Weng doesn\u2019t expand on the STM here in the way we did above  :</p> <p></p> <p>Broader, more relevant representation of memory for our context, and the corresponding data processing, based on Atkinson-Schiffrin memory model would be:</p> <p></p>","tags":["pydantic","langchain","llm","openai","functions","pdfs"]},{"location":"blog/posts/from-demo-to-production-1/#2-level-0-the-current-state-of-affairs","title":"2. Level 0: The Current State of Affairs","text":"<p>To understand the current LLM production systems, how they handle data input and processing, and their evolution, we start at Level 0 \u2014 the LLMs and their APIs as they are currently \u2014 and progress toward Level 7 \u2014 AI Agents and complex AI Data Platforms and Agent Networks of the future.</p>","tags":["pydantic","langchain","llm","openai","functions","pdfs"]},{"location":"blog/posts/from-demo-to-production-1/#21-developer-intent-at-level-0","title":"2.1. Developer Intent at Level 0","text":"<p>In order to extract relevant data from PDF documents, as an engineer you would turn to a powerful AI model like OpenAI, Anthropic, or Cohere (Layer 0 in our XYZ stack). Not all of them support this functionality, so you\u2019d use Bing or a ChatGPT plugin like AskPDF, which do.</p> <p>In order to \"extract nuances,\" you might provide the model with specific examples or more directive prompts. For instance, \"Identify the vendor name positioned near the top of the invoice, usually above the billing details.\"</p> <p>Next, you'd \"prompt it\" with various PDFs to see how it reacts. Based on the outputs, you might notice that it misses handwritten dates or gets confused with certain fonts.</p> <p>This is where \"prompt engineering\" comes in. You might adjust your initial prompt to be more specific or provide additional context. Maybe you now say, \"Identify the vendor name and, if you find any handwritten text, treat it as the invoice date.\"</p>","tags":["pydantic","langchain","llm","openai","functions","pdfs"]},{"location":"blog/posts/from-demo-to-production-1/#22-toward-the-production-code-from-the-chatbot-ux-poc-at-level-0","title":"2.2 Toward the production code from the chatbot UX - POC at level 0","text":"<p>Our POC at this stage consists of simply uploading a PDF and asking it questions until we have better and better answers based on prompt engineering. This exercise shows what is available with the current production systems, to help us set a baseline for the solutions to come.</p> <ul> <li>If your goal is to understand the content of a PDF, Bing and OpenAI will enable you to upload documents and get explanations of their contents</li> <li>Uses basic natural language processing (NLP) prompts without any schema on output data</li> <li>Typically \u201cforgets\u201d the data after a query \u2014 no notion of storage (LTM)</li> <li>In a production environment, data loss can have significant consequences. It can lead to operational disruptions, inaccurate analytics, and loss of valuable insights</li> <li>There is no possibility to test the behavior of the system</li> </ul> <p>Let\u2019s break down the Data Platform component at this stage:</p> Memory type State Description Sensory Memory Chatbot interface Can be interpreted in this context as the interface used for the human input STM The context window of the chatbot/search. In essence stateless The processing layer and a storage of the session/user context LTM Not present at this stage The information storage <p>Lacks:</p> <ul> <li>Decoupling: Separating components to reduce interdependency.</li> <li>Portability: Ability to run in different environments.</li> <li>Modularity: Breaking down into smaller, independent parts.</li> </ul> <p>Extendability: Capability to add features or functionality.</p> <p>Next Steps:</p> <ol> <li>Implement a LTM memory component for information retention.</li> <li>Develop an abstraction layer for Sensory Memory input and processing multiple file types.</li> </ol> <p>Addressing these points will enhance flexibility, reusability, and adaptability.</p>","tags":["pydantic","langchain","llm","openai","functions","pdfs"]},{"location":"blog/posts/from-demo-to-production-1/#23-summary-ask-pdf-questions","title":"2.3 Summary - Ask PDF questions","text":"Description Use-Case Summary Memory Maturity Production readiness The Foundational Model Extract info from your documents ChatGPT prompt engineering as the only way to optimise outputs SM, STM are system defined, LTM is not present Works 15% of time Lacks Decoupling, Portability, Modularity and Extendability","tags":["pydantic","langchain","llm","openai","functions","pdfs"]},{"location":"blog/posts/from-demo-to-production-1/#24-addendum-companies-in-the-space-openai-anthropic-and-cohere","title":"2.4. Addendum - companies in the space: OpenAI, Anthropic, and Cohere","text":"<ul> <li>A brief on each provider, relevant model and its role in the modern data space.</li> <li> <p>The list of models and providers in the space</p> Model Provider Structured data Speed Params Fine Tunability gpt-4 OpenAI\u00a0 Yes \u2605\u2606\u2606\u00a0 \u00a0- No gpt-3.5-turbo OpenAI Yes \u2605\u2605\u2606\u00a0 \u00a0175B No gpt-3 OpenAI No\u00a0 \u00a0\u2605\u2606\u2606 \u00a0175B No ada, babbage, curie \u00a0OpenAI No \u2605\u2605\u2605\u00a0 \u00a0350M - 7B Yes claude Anthropic\u00a0 No \u2605\u2605\u2606\u00a0 \u00a052B No\u00a0 claude-instant Anthropic\u00a0 No \u2605\u2605\u2605\u00a0 \u00a052B No command-xlarge Cohere No \u00a0\u2605\u2605\u2606 \u00a050B Yes command-medium Cohere No \u00a0\u2605\u2605\u2605 \u00a06B Yes BERT Google\u00a0 No \u2605\u2605\u2605\u00a0 345M\u00a0 Yes \u00a0T5 Google\u00a0 No \u2605\u2605\u2606\u00a0 \u00a011B Yes PaLM\u00a0 Google\u00a0 No \u00a0\u2605\u2606\u2606 \u00a0540B Yes LLaMA Meta AI\u00a0 Yes \u2605\u2605\u2606\u00a0 \u00a065B Yes \u00a0CTRL Salesforce\u00a0 No \u2605\u2605\u2605\u00a0 1.6B\u00a0 Yes Dolly 2.0\u00a0 Databricks No \u2605\u2605\u2606\u00a0 \u00a012B Yes\u00a0 </li> </ul>","tags":["pydantic","langchain","llm","openai","functions","pdfs"]},{"location":"blog/posts/from-demo-to-production-1/#3-level-1-langchain-weaviate","title":"3**. Level 1:  Langchain &amp; Weaviate**","text":"","tags":["pydantic","langchain","llm","openai","functions","pdfs"]},{"location":"blog/posts/from-demo-to-production-1/#31-developer-intent-at-level-1-langchain-weaviate-llm-wrapper","title":"3.1. Developer Intent at Level 1**: Langchain &amp; Weaviate LLM Wrapper**","text":"<p>This step is basically an upgrade to the current state of the art LLM UX/UI where we add:</p> <ul> <li> <p>Permanent LTM memory (data store)</p> <p>As a developer, I need to answer questions on large PDFs that I can\u2019t simply pass to the LLM due to technical limitations. The primary issue being addressed is the constraint on prompt length. As of now, GPT-4 has a limit of 4k tokens for both the prompt and the response combined. So, if the prompt comprises 3.5k tokens, the response can only be 0.5k tokens long.</p> </li> <li> <p>LLM Framework like Langchain to adapt any document type to vector store</p> <p>Using Langchain provides a neat abstraction for me to get started quickly, connect to VectorDB, and get fast results.</p> </li> <li> <p>Some higher level structured storage (dlthub)</p> </li> </ul> <p></p>","tags":["pydantic","langchain","llm","openai","functions","pdfs"]},{"location":"blog/posts/from-demo-to-production-1/#32-translating-theory-into-practice-poc-at-level-1","title":"3.2. Translating Theory into Practice: POC at Level 1","text":"<ul> <li>LLMs can\u2019t process all the data that a large PDF could contain. So, we need a place to store the PDF and a way to retrieve relevant information from it, so it can be passed on to the LLM.</li> <li>When trying to build and process documents or user inputs, it\u2019s important to store them in a Vector Database to be able to retrieve the information when needed, along with the past context.</li> <li>A vector database is the optimal solution because it enables efficient storage, retrieval, and processing of high-dimensional data, making it ideal for applications like document search and user input analysis where context and similarity are important.</li> <li>For the past several months, there has been a surge of projects that personalize LLMs by storing user settings and information in a VectorDB so they can be easily retrieved and used as input for the LLM.</li> </ul> <p>This can be done by storing data in the Weaviate Vector Database; then, we can process our PDF.</p> <ul> <li>We start by converting the PDF and translating it</li> </ul> <p></p> <ul> <li>the next step we store the PDF to Weaviate</li> </ul> <p></p> <ul> <li>We load the data into some type of database using dlthub</li> </ul> <p></p> <p>The parallel with our memory components becomes clearer at this stage. We have some way to define inputs which correspond to SM, while STM and LTM are starting to become two separate, clearly distinguishable entities. It becomes evident that we need to separate LTM data according to domains it belongs to but, at this point, a clear structure for how that would work has not yet emerged.</p> <p>In addition, we can treat GPT as limited working memory and its context size as how much our model can remember during one operation.</p> <p>It\u2019s evident that, if we don\u2019t manage the working memory well, we will overload it and fail to retrieve outputs. So, we will need to take a closer look into how humans do the same and how our working memory manages millions of facts, emotions, and senses swirling around our minds.</p> <p>Let\u2019s break down the Data Platform components at this stage:</p> Memory type State Description Sensory Memory Command line interface + arguments Can be interpreted in this context as the arguments provided to the script STM Partially Vector store, partially working memory The processing layer and a storage of the session/user context LTM Vector store The raw document storage <p>Sensory Memory</p> <p>Sensory memory can be seen as an input buffer where the information from the environment is stored temporarily. In our case, it\u2019s the arguments we give to the command line script. </p> <p>STM</p> <p>STM is often associated with the concept of \"working memory,\" which holds and manipulates information for short periods.</p> <p>In our case, it is the time during which the process runs. </p> <p>LTM</p> <p>LTM can be conceptualized as a database in software systems. Databases store, organize, and retrieve data over extended periods. The information in LTM is organized and indexed, similar to how databases use tables, keys, and indexes to categorize and retrieve data efficiently.</p> <p>VectorDB: The LTM Storage of Our AI Data Platform</p> <p>Unlike traditional relational databases, that store data in tables, and newer NoSQL databases like MongoDB, that use JSON documents, vector databases specifically store and fetch vector embeddings.</p> <p>Vector databases are crucial for Large Language Models and other modern, resource-hungry applications. They're designed for handling vector data, commonly used in fields like computer graphics, Machine Learning, and Geographic Information Systems.</p> <p>Vector databases hinge on vector embeddings. These embeddings, packed with semantic details, help AI systems to understand data and retain long-term memory. They're condensed snapshots of training data and act as filters when processing new data in the inference stage of machine learning.</p> <p>Problems:</p> <ul> <li>Interoperability</li> <li>Maintainability</li> <li>Fault Tolerance</li> </ul> <p>Next steps:</p> <ol> <li>Create a standardized data model</li> <li>Dockerize the component</li> <li>Create a FastAPI endpoint</li> </ol>","tags":["pydantic","langchain","llm","openai","functions","pdfs"]},{"location":"blog/posts/from-demo-to-production-1/#34-summary-the-thing-startup-bros-pitch-to-vcs","title":"3.4. Summary - The thing startup bros pitch to VCs","text":"Description Use-Case Summary Knowledge Maturity Production readiness Interface Endpoint for the Foundational Model Store data and query it for a particular use-case Langchain + Weaviate to improve user\u2019s conversations + prompt engineering to get better outputs SM is somewhat modifiable, STM is not clearly defined, LTM is a VectorDB Works 25% of time Lacks Interoperability, Maintainability, Fault Tolerance Has some: Reusability, Portability, Extendability","tags":["pydantic","langchain","llm","openai","functions","pdfs"]},{"location":"blog/posts/from-demo-to-production-1/#35-addendum-frameworks-and-vector-dbs-in-the-space-langchain-weaviate-and-others","title":"3.5. Addendum - Frameworks and Vector DBs in the space: Langchain, Weaviate and others","text":"<ul> <li>A brief on each provider, relevant model and its role in the modern data space.</li> <li> <p>The list of models and providers in the space</p> Tool/Service Tool type Ease of use Maturity Docs Production readiness Langchain Orchestration framework \u2605\u2605\u2606\u00a0 \u2605\u2606\u2606\u00a0 \u2605\u2605\u2606\u00a0 \u2605\u2606\u2606\u00a0 Weaviate VectorDB \u2605\u2605\u2606\u00a0 \u2605\u2605\u2606\u00a0 \u2605\u2605\u2606\u00a0 \u2605\u2605\u2606\u00a0 Pinecone VectorDB \u2605\u2605\u2606\u00a0 \u2605\u2605\u2606\u00a0 \u2605\u2605\u2606\u00a0 \u2605\u2605\u2606\u00a0 ChromaDB VectorDB \u2605\u2605\u2606\u00a0 \u2605\u2606\u2606\u00a0 \u2605\u2606\u2606\u00a0 \u2605\u2606\u2606\u00a0 Haystack Orchestration framework \u2605\u2605\u2606\u00a0 \u2605\u2606\u2606\u00a0 \u2605\u2605\u2606\u00a0 \u2605\u2606\u2606\u00a0 Huggingface's New Agent System Orchestration framework \u2605\u2605\u2606\u00a0 \u2605\u2606\u2606\u00a0 \u2605\u2605\u2606\u00a0 \u2605\u2606\u2606\u00a0 Milvus VectorDB \u2605\u2605\u2606\u00a0 \u2605\u2606\u2606\u00a0 \u2605\u2605\u2606\u00a0 \u2605\u2606\u2606\u00a0 https://gpt-index.readthedocs.io/ Orchestration framework \u2605\u2605\u2606\u00a0 \u2605\u2606\u2606\u00a0 \u2605\u2605\u2606\u00a0 \u2605\u2606\u2606\u00a0 </li> </ul>","tags":["pydantic","langchain","llm","openai","functions","pdfs"]},{"location":"blog/posts/from-demo-to-production-1/#resources","title":"Resources","text":"","tags":["pydantic","langchain","llm","openai","functions","pdfs"]},{"location":"blog/posts/from-demo-to-production-1/#blog-posts","title":"Blog Posts:","text":"<ol> <li>Large Action Models</li> <li>Making Data Ingestion Production-Ready: A LangChain-Powered Airbyte Destination</li> <li>The Problem with LangChain</li> </ol>","tags":["pydantic","langchain","llm","openai","functions","pdfs"]},{"location":"blog/posts/from-demo-to-production-1/#research-papers-arxiv","title":"Research Papers (ArXiv):","text":"<ol> <li>Research Paper 1</li> <li>Research Paper 2</li> <li>Research Paper 3</li> </ol>","tags":["pydantic","langchain","llm","openai","functions","pdfs"]},{"location":"blog/posts/from-demo-to-production-1/#web-comics","title":"Web Comics:","text":"<ol> <li>xkcd comic</li> </ol>","tags":["pydantic","langchain","llm","openai","functions","pdfs"]},{"location":"blog/posts/from-demo-to-production-1/#reddit-discussions","title":"Reddit Discussions:","text":"<ol> <li>Reddit Discussion: The Problem with LangChain</li> </ol>","tags":["pydantic","langchain","llm","openai","functions","pdfs"]},{"location":"blog/posts/from-demo-to-production-1/#developer-blog-posts","title":"Developer Blog Posts:","text":"<ol> <li>Unlocking the Power of Enterprise-Ready LLMS with NeMo</li> </ol>","tags":["pydantic","langchain","llm","openai","functions","pdfs"]},{"location":"blog/posts/from-demo-to-production-1/#industry-analysis","title":"Industry Analysis:","text":"<ol> <li>Emerging Architectures for LLM Applications</li> </ol>","tags":["pydantic","langchain","llm","openai","functions","pdfs"]},{"location":"blog/posts/from-demo-to-production-1/#prompt-engineering","title":"Prompt Engineering:","text":"<ol> <li>Prompting Guide</li> <li>Tree of Thought Prompting: Walking the Path of Unique Approach to Problem Solving</li> </ol>","tags":["pydantic","langchain","llm","openai","functions","pdfs"]},{"location":"blog/posts/from-demo-to-production-1/#conclusion","title":"Conclusion","text":"<p>If you enjoy the content or want to try out <code>cognee</code> please check out the github and give us a star!</p>","tags":["pydantic","langchain","llm","openai","functions","pdfs"]},{"location":"blog/posts/from-demo-to-production-2/","title":"From demo to production 2","text":"<p>draft: False date: 2023-10-05 tags:   - pydantic   - langchain   - llm   - openai    - functions   - pdfs authors:   - tricalt</p>"},{"location":"blog/posts/from-demo-to-production-2/#going-beyond-langchain-weaviate-level-2-towards-production","title":"Going beyond Langchain + Weaviate: Level 2 towards Production","text":""},{"location":"blog/posts/from-demo-to-production-2/#11-the-problem-of-putting-code-to-production","title":"1.1. The problem of putting code to production","text":"<p>This post is a part of a series of texts aiming to discover and understand patterns and practices that would enable building a production-ready AI data infrastructure. The main focus is on how to evolve data modeling and retrieval in order to enable Large Language Model (LLM) apps and Agents to serve millions of users concurrently.</p> <p>For a broad overview of the problem and our understanding of the current state of the LLM landscape, check out our previous post</p> <p></p> <p>In this text, we continue our inquiry into what would constitute:</p> <ol> <li>Proper data engineering methods for LLMs</li> <li>A production-ready generative AI data platform that unlocks AI assistants/Agent Networks</li> </ol> <p>To explore these points, we here at prometh.ai have partnered with dlthub in order to productionize a common use case \u2014 complex PDF processing \u2014 progressing level by level.</p> <p>In the previous text, we wrote a simple script that relies on the Weaviate Vector database to turn unstructured data into structured data and help us make sense of it.</p> <p>In this post, some of the shortcomings from the previous level will be addressed, including::</p> <ol> <li>Containerization</li> <li>Data model</li> <li>Data contract</li> <li>Vector Database retrieval strategies</li> <li>LLM context and task generation</li> <li>Dynamic Agent behavior and Agent tooling</li> </ol>"},{"location":"blog/posts/from-demo-to-production-2/#3-level-2-memory-layer-fastapi-langchain-weaviate","title":"3. Level 2:  Memory Layer + FastAPI + Langchain + Weaviate","text":""},{"location":"blog/posts/from-demo-to-production-2/#31-developer-intent-at-level-2","title":"3.1. Developer Intent at Level 2","text":"<p>This phase enhances the basic script by incorporating:</p> <ul> <li> <p>Memory Manager</p> <p>The memory manager facilitates the execution and processing of VectorDB data by:</p> <ol> <li>Uniformly applying CRUD (Create, Read, Update, Delete) operations across various classes</li> <li>Representing different business domains or concepts, and</li> <li>Ensuring they adhere to a common data model, which regulates all data points across the system.</li> <li>Context Manager</li> </ol> <p>This central component processes and analyzes data from Vector DB, evaluates its significance, and compares the results with user-defined benchmarks.</p> <p>The primary objective is to establish a mechanism that encourages in-context learning and empowers the Agent\u2019s adaptive understanding.</p> <p>As an example, let\u2019s assume we uploaded the book A Call of the Wild by Jack London to our Vector DB semantic layer, to give our LLM a better understanding of the life of sled dogs in the early 1900s.</p> <p>Asking a question about the contents of the book will yield a straightforward answer, provided that the book contains an explicit answer to our question.</p> <p>To enable better question answering and access to additional information such as historical context, summaries, and other documents, we need to introduce different memory stores and a set of attention modulators, which are meant to manage the prioritization of data retrieved for the answers.</p> </li> <li> <p>Task Manager</p> <p>Utilizing the tools at hand and guided by the user's prompt, the task manager determines a sequence of actions and their execution order.</p> <p>For example, let\u2019s assume that the user asks: \u201cWhen was Buck (one of the dogs from A Call of the Wild) kidnapped\u201d and to have the answer translated to German\u201d</p> <p>This query would be broken down by the task manager into a set of atomic tasks that can then be handed over to the Agent.</p> <p>The ordered task list could be:</p> <ol> <li>Retrieve information about the PDF from the database.</li> <li>Translate the information to German.</li> <li>The Agent</li> </ol> <p>AI agents can use computers independently. They can browse the web, use apps, read and write files, make credit card payments, and even autonomously execute processes on your personal computer.</p> <p>In our case, the Agent has only a few tools at its disposal, such as tools to translate text or structure data. Using these tools, it processes and executes tasks in the sequence they are provided by the Task Manager and the Context Manager.</p> </li> </ul>"},{"location":"blog/posts/from-demo-to-production-2/#32-toward-the-memory-layer-poc-at-level-2","title":"3.2 Toward the memory layer - POC at level 2","text":"<p>At this stage, our proof of concept (POC) allows uploading a PDF document and requesting specific actions on it such as \"load to database\", \"translate to German\", or \"convert to JSON.\" Prior task resolutions and potential operations are assessed by the Context Manager and Task Manager services.</p> <p>The following set of steps explains the workflow of the POC at level 2:</p> <ul> <li>Initially, we specify the parameters for the document we wish to upload and define our objective in the prompt:</li> </ul> <p></p> <ul> <li> <p>The memory manager retrieves the parameters and the attention modulators and creates context based on Episodic and Semantic memory stores (previous runs of the job + raw data):</p> <p></p> </li> <li> <p>To do this, it starts by filtering user input, in the same way our brains filter important from redundant information. As an example, if there are children playing and talking loudly in the background during our Zoom meeting, we can still pool our attention together and focus on what the person on the other side is saying.</p> <p>The same principle is applied here:</p> </li> </ul> <p></p> <ul> <li> <p>In the next step, we apply a set of attention modulators to process the data obtained from the Vector Store.</p> <p>NOTE: In cognitive science, attention modulators can be thought of as factors or     mechanisms that influence the direction and intensity of attention.</p> <p>As we have many memory stores, we need to prioritize the data points that we retrieve via semantic search.</p> <p>Since semantic search is not enough by itself, scoring data points happens via a set of functions that replicate how attention modulators work in cognitive science.</p> <p>Initially, we\u2019ve implemented a few attention modulators that we thought could improve the document retrieval process:</p> <p>Frequency: This refers to how often a specific stimulus or event is encountered. Stimuli that are encountered more frequently are more likely to be attended to or remembered.</p> <p>Recency: This refers to how recently a stimulus or event was encountered. Items or events that occurred more recently are typically easier to recall than those that occurred a long time ago.</p> </li> </ul> <p>We have implemented many more, and you can find them in our</p> <p>repository. More are still needed and contributions are more than welcome.</p> <p>Let\u2019s see the modulators in action:</p> <p></p> <p>In the code above we fetch the memories from the Semantic Memory bank where our knowledge of the world is stored (the PDFs). We select the relevant documents by using the handle_modulator function.</p> <ul> <li>The handle_modulator function is defined below and explains how scoring of memories happens.</li> </ul> <p></p> <p>We process the data retrieved with OpenAI functions and store the results for the Task Manager to be able to determine what actions the Agent should take.</p> <p>The Task Manager then sorts and converts user input into a set of actionable steps based on the tools available.</p> <p></p> <p>Finally, the Agent interprets the context and performs the steps using the tools it has available. We see this as the step where the Agents take over the task, executing it in their own way.</p> <p>Now, let's look back at what constitutes the Data Platform:</p> Memory type State Description Sensory Memory API Can be interpreted in this context as the interface used for the human input STM Weaviate Class with hardcoded contract The processing layer and a storage of the session/user context LTM Weaviate Class with hardcoded contract The information storage <p>Lacks:</p> <ul> <li>Extendability: Capability to add features or functionality.</li> <li>Loading flexibility: Ability to apply different chunking strategies</li> <li>Testability: How to test the code and make sure it runs</li> </ul> <p>Next Steps:</p> <ol> <li>Implement different strategies for vector search</li> <li>Add more tools to process PDFs</li> <li>Add more attention modulators</li> <li>Add a solid test framework</li> </ol>"},{"location":"blog/posts/from-demo-to-production-2/#conclusion","title":"Conclusion","text":"<p>If you enjoy the content or want to try out <code>cognee</code> please check out the github and give us a star!</p>"},{"location":"blog/posts/from-demo-to-production-3/","title":"From demo to production 3","text":"<p>draft: False date: 2023-10-05 tags:   - pydantic   - langchain   - llm   - openai    - functions   - pdfs authors:   - tricalt</p>"},{"location":"blog/posts/from-demo-to-production-3/#going-beyond-langchain-weaviate-level-3-towards-production","title":"Going beyond Langchain + Weaviate: Level 3 towards production","text":""},{"location":"blog/posts/from-demo-to-production-3/#preface","title":"Preface","text":"<p>This post is part of a series of texts aiming to explore and understand patterns and practices that enable the construction of a production-ready AI data infrastructure. The main focus of the series is on the modeling and retrieval of evolving data, which would empower Large Language Model (LLM) apps and Agents to serve millions of users concurrently.</p> <p>For a broad overview of the problem and our understanding of the current state of the LLM landscape, check out our initial post here.</p> <p>In this post, we delve into context enrichment and testing in Retrieval Augmented Generation (RAG) applications.</p> <p>RAG applications can retrieve relevant information from a knowledge base and generate detailed, context-aware answers to user queries.</p> <p>As we are trying to improve on the base information LLMs are giving us, we need to be able to retrieve and understand more complex data, which can be stored in various data stores, in many formats, and using different techniques.</p> <p>All of this leads to a lot of opportunities, but also creates a lot of confusion in generating and using RAG applications and extending the existing context of LLMs with new knowledge.</p>"},{"location":"blog/posts/from-demo-to-production-3/#1-context-enrichment-and-testing-in-rag-applications","title":"1. Context Enrichment and Testing in RAG Applications","text":"<p>In navigating the complexities of RAG applications, the first challenge we face is the need for robust testing. Determining whether augmenting a LLM's context with additional information will yield better results is far from straightforward and often relies on subjective assessments.</p> <p>Imagine, for instance, adding the digital version of the book The Adventures of Tom Sawyer to the LLM's database in order to enrich its context and obtain more detailed answers about the book's content for a paper we're writing. To evaluate this enhancement, we need a way to measure the accuracy of the responses before and after adding the book while considering the variations of every adjustable parameter.</p>"},{"location":"blog/posts/from-demo-to-production-3/#2-adjustable-parameters-in-rag-applications","title":"2. Adjustable Parameters in RAG Applications","text":"<p>The end-to-end process of enhancing RAG applications involves various adjustable parameters, which offer multiple paths toward achieving similar goals with varying outcomes. These parameters include:</p> <ol> <li>Number of documents loaded into memory.</li> <li>Size of each sub-document chunk uploaded.</li> <li>Overlap between documents uploaded.</li> <li>Relationship between documents (Parent-Son etc.)</li> <li>Type of embedding used for data-to-vector conversion (OpenAI, Cohere, or any other embedding method).</li> <li>Metadata structure for data navigation.</li> <li>Indexes and data structures.</li> <li>Search methods (text, semantic, or fusion search).</li> <li>Output retrieval and scoring methods.</li> <li>Integration of outputs with other data for in-context learning.</li> <li>Structure of the final output.</li> </ol>"},{"location":"blog/posts/from-demo-to-production-3/#3-the-role-of-memory-manager-at-level-3","title":"3. The Role of Memory Manager at Level 3","text":"<p>Memory Layer + FastAPI + Langchain + Weaviate</p> <p>3.1. Developer Intent at Level 3</p> <p>The goal we set for our system in our initial post \u2014 processing and creating structured data from PDFs \u2014 presented an interesting set of problems to solve. OpenAI functions and dlthub allowed us to accomplish this task relatively quickly.</p> <p>The real issue arises when we try to scale this task \u2014 this is what our second post tried to address. In addition, retrieving meaningful data from the Vector Databases turned out to be much more challenging than initially imagined.</p> <p>In this post, we\u2019ll discuss how we can establish a testing method, improve our ability to retrieve the information we've processed, and make the codebase more robust and production-ready.</p> <p>We\u2019ll primarily focus on the following:</p> <ol> <li> <p>Memory Manager</p> <p>The Memory Manager is a set of functions and tools for creating dynamic memory objects. In our previous blog posts, we explored the application of concepts from cognitive science \u2014\u00a0 Short-Term Memory, Long-Term Memory, and Cognitive Buffer \u2014 on Agent Network development.</p> <p>We might need to add more memory domains to the process, as sticking to just these three can pose limitations. Changes in the codebase now enable real-time creation of dynamic memory objects, which have hierarchical relationships and can relate to each other.</p> </li> <li> <p>RAG test tool</p> <p>The RAG test tool allows us to control critical parameters for optimizing and testing RAG applications, including chunk size, chunk overlap, search type, metadata structure, and more.</p> </li> </ol> <p>The Memory Manager is a crucial component of any cognitive architecture platform. In our previous posts, we\u2019ve discussed how to turn unstructured data to structured, how to relate concepts to each other in the vector store, and which problems can arise when productionizing these systems.</p> <p>While we\u2019ve addressed many open questions, many still remain. Based on our surveys and interviews with field experts, applications utilizing Memory components face the following challenges:</p> <ol> <li> <p>Inability to reliably link between Memories</p> <p>Relying solely on semantic search or its derivatives to recognize the similarities between terms like \"pair\" and \"combine\" is a step forward. However, actually defining, capturing, and quantifying the relationships between any two objects would aid future memory access.</p> <p>Solution: Graphs/Traditional DB</p> </li> <li> <p>Failure to structure and organize Memories</p> <p>We used OpenAI functions to structure and organize different Memory elements and convert them into understandable JSONs. Nevertheless, our surveys indicate that many people struggle with metadata management and the structure of retrievals. Ideally, these aspects should all be managed and organized in one place.</p> <p>Solution: OpenAI functions/Data contracting/Metadata management</p> </li> <li> <p>Hierarchy, size, and relationships of individual Memory elements</p> <p>Although semantic search helps us understand the same concepts, we need to add more abstract concepts and ideas and link them. The ultimate goal is to emulate human understanding of the world, which comprises basic concepts that, when combined, create higher complexity objects.</p> <p>Solution: Graphs/Custom solutions</p> </li> <li> <p>Evaluation possibilities of memory components (can they be distilled to True/False)</p> <p>Based on the psycholinguistic theories proposed by Walter Kintsch, any cognitive system should be able to provide True/False evaluations. Kintsch defines a basic memory component, a \u2018proposition,\u2019 which can be evaluated as True or False and can interlink with other Memory components.</p> <p>A proposition could be, for example, \"The sky is blue,\" and its evaluation to True/False could lead to actions such as \"Do not bring an umbrella\" or \"Wear a t-shirt.\"</p> <p>Potential solution: Particular memory structure</p> </li> </ol>"},{"location":"blog/posts/from-demo-to-production-3/#testability-of-memory-components","title":"Testability of Memory components","text":"<p>We should have a reliable method to test Memory components, at scale, for any number of use-cases. We need benchmarks across every level of testing to capture and define predicted behavior.</p> <p>Suppose we need to test if Memory data from six months ago can be retrieved by our system and measure how much it contributes to a response that spans memories that are years old.</p> <p>Solution: RAG testing framework</p> <p></p> <p>Let\u2019s look at the RAG testing framework:</p> <p>It allows to you to test and combine all variations of: </p> <ol> <li>Number of documents loaded into memory.  \u2705</li> <li>Size of each sub-document chunk uploaded. \u2705</li> <li>Overlap between documents uploaded.  \u2705</li> <li>Relationship between documents (Parent-Son etc.) \ud83d\udc77\ud83c\udffb\u200d\u2642\ufe0f</li> <li>Type of embedding used for data-to-vector conversion (OpenAI, Cohere, or any other embedding method).  \u2705</li> <li>Metadata structure for data navigation.  \u2705</li> <li>Indexes and data structures.  \u2705</li> <li>Search methods (text, semantic, or fusion search).  \u2705</li> <li>Output retrieval and scoring methods. \ud83d\udc77\ud83c\udffb\u200d\u2642\ufe0f</li> <li>Integration of outputs with other data for in-context learning. \ud83d\udc77\ud83c\udffb\u200d\u2642\ufe0f</li> <li>Structure of the final output.  \u2705</li> </ol> <p>These parameters and results of the tests will be stored in Postgres database and can be visualized using Superset</p> <p>To try it, navigate to: https://github.com/topoteretes/PromethAI-Memory</p> <p>Copy the .env.template to .env and fill in the variables</p> <p>Specify the environment variable in the .env file to \"local\"</p> <p>Use the poetry environment:</p> <p><code>poetry shell</code></p> <p>Change the .env file Environment variable to \"local\"</p> <p>Launch the postgres DB</p> <p><code>docker compose up postgres</code></p> <p>Launch the superset</p> <p><code>docker compose up superset</code></p> <p>Open the superset in your browser</p> <p><code>http://localhost:8088</code>\u00a0Add the Postgres datasource to the Superset with the following connection string:</p> <p><code>postgres://bla:bla@postgres:5432/bubu</code></p> <p>Make sure to run to initialize DB tables</p> <p><code>python scripts/create_database.py</code></p> <p>After that, you can run the RAG test manager from your command line.</p> <pre><code>    python rag_test_manager.py \\\n    --file \".data\" \\\n    --test_set \"example_data/test_set.json\" \\\n    --user_id \"97980cfea0067\" \\\n    --params \"chunk_size\" \"search_type\" \\\n    --metadata \"example_data/metadata.json\" \\\n    --retriever_type \"single_document_context\"\n</code></pre> <p>Examples of metadata structure and test set are in the folder \"example_data\"</p>"},{"location":"blog/posts/from-demo-to-production-3/#conclusion","title":"Conclusion","text":"<p>If you enjoy the content or want to try out <code>cognee</code> please check out the github and give us a star!</p>"},{"location":"blog/posts/from-demo-to-production-4/","title":"From demo to production 4","text":"<p>draft: False date: 2023-12-05 tags:   - pydantic   - langchain   - llm   - openai    - functions   - pdfs authors:   - tricalt</p>"},{"location":"blog/posts/from-demo-to-production-4/#going-beyond-langchain-weaviate-level-4-towards-production","title":"Going beyond Langchain + Weaviate: Level 4 towards production","text":""},{"location":"blog/posts/from-demo-to-production-4/#preface","title":"Preface","text":"<p>This post is part of a series of texts aiming to explore and understand patterns and practices that enable the construction of a production-ready AI data infrastructure. The series mainly focuses on the modeling and retrieval of evolving data, which would empower Large Language Model (LLM) apps and Agents to serve millions of users concurrently.</p> <p>For a broad overview of the problem and our understanding of the current state of the LLM landscape, check out our initial post here.</p> <p></p> <p>In this post, we delve into creating an initial data platform that can represent the core component of the future MlOps stack. Building a data platform is a big challenge in itself, and many solutions are available to help automate data tracking, ingestion, data contracting, monitoring, and warehousing.</p> <p>In the last decade, data analytics and engineering fields have undergone significant transformations, shifting from storing data in centralized, siloed Oracle and SQL Server warehouses to a more agile, modular approach involving real-time data and cloud solutions like BigQuery and Snowflake.</p> <p>Data processing evolved from an inessential activity, whose value would be inflated to please investors during the startup valuation phase, to a fundamental component of product development.</p> <p>As we enter a new paradigm of interacting with systems through natural language, it's important to recognize that, while this method promises efficiency, it also comes with the challenges inherent in the imperfections of human language.</p> <p>Suppose we want to use natural language as a new programming tool. In that case, we will need to either impose more constraints on it or make our systems more flexible so that they can adapt to the equivocal nature of language and information.</p> <p>Our main goal should be to offer consistency, reproducibility and more that would ideally use language as a basic building block for things to come.</p> <p>In order to come up with a set of solutions that could enable us to move forward, in this series of posts, we call on theoretical models from cognitive science and try to incorporate them into data engineering practices .</p>"},{"location":"blog/posts/from-demo-to-production-4/#level-4-memory-architecture-and-a-first-integration-with-keepiai","title":"Level 4: Memory architecture and a first integration with keepi.ai","text":"<p>In our initial post, we started out conceptualizing a simple retrieval-augmented generation (RAG) model whose aim was to process and understand PDF documents.</p> <p>We faced many bottlenecks in scaling these tasks, so in our second post, we needed to introduce the concept of memory domains..</p> <p>In the next step, the focus was mainly on understanding what makes a good RAG considering all possible variables.</p> <p>In this post, we address the fundamental question of the feasibility of extending LLMs beyond the data on which they were trained.</p> <p>As a Microsoft research team recently stated:</p> <ul> <li>Baseline RAG struggles to connect the dots when answering a question requires providing synthesized insights by traversing disparate pieces of information through their shared attributes.</li> <li>Baseline RAG performs poorly when asked to understand summarized semantic concepts holistically over large data collections or even singular large documents.</li> </ul> <p>To fill these gaps in RAG performance, we built a new framework\u2014cognee.</p> <p>Cognee combines human-inspired cognitive processes with efficient data management practices, infusing data points with more meaningful relationships to represent the (often messy) natural world in code more accurately.</p> <p>Our observations indicate that systems, agents, and interactions often falter due to overextension and haste.</p> <p>However, given the extensive demands and expectations surrounding Large Language Models (LLMs), addressing every aspect\u2014agents, actions, integrations, and schedulers\u2014is beyond the scope of the framework\u2019s mission.</p> <p>We've chosen to prioritize data, recognizing that the crux of many issues has already been addressed within the realm of data engineering.</p> <p>We aim to establish a framework that includes file storage, tracing, and the development of robust AI memory data pipelines to help us manage and structure data more efficiently through its transformation processes.</p> <p>Subsequently, our goal will be to devise methods for navigating diverse information segments and determine the most effective application of graph databases to store this data.</p> <p>Our initial hypothesis\u2014enhancing data management in vector stores through manipulative techniques and attention modulators for input and retrieval\u2014proved less effective than anticipated.</p> <p>Deconstructing and reorganizing data via graph databases emerged as a superior strategy, allowing us to adapt and repurpose existing tools for our needs more effectively.</p> AI Memory type State in Level 2 State in Level 4 Description Sensory Memory API API Can be interpreted in this context as the interface used for the human input STM Weaviate Class with hardcoded contract Neo4j  with a connection to a Weaviate class The processing layer and a storage of the session/user context LTM Weaviate Class with hardcoded contract Neo4j with a connection to a Weaviate class The information storage <p>On Level 4, we describe the integration of keepi, a chatGPT-powered WhatsApp bot that collects and summarizes information, via API endpoints.</p> <p>Then, once we\u2019ve ensured that we have a robust, scalable infrastructure, we deploy cognee to the cloud.</p>"},{"location":"blog/posts/from-demo-to-production-4/#workflow-overview","title":"Workflow Overview","text":"<p>Steps:</p> <ol> <li>Users submit queries or documents for storage via the keepi.ai WhatsApp bot. This step integrates with the keepi.ai platform, utilizing Cognee endpoints for processing.</li> <li>The Cognee manager handles the incoming request and collaborates with several components:<ol> <li>Relational database: Manages state and metadata related to operations.</li> <li>Classifier: Identifies, organizes, and enhances the content.</li> <li>Loader: Archives data in vector databases.</li> </ol> </li> <li>The Graph Manager and Vector Store Manager collaboratively process and organize the input into structured nodes. A key function of the system involves breaking down user input into propositions\u2014basic statements retaining factual content. These propositions are interconnected through relationships and cataloged in the Neo4j database by the Graph Manager, associated with specific user nodes. Users are represented by memory nodes that capture various memory levels, some of which link back to the raw data in vector databases.</li> </ol>"},{"location":"blog/posts/from-demo-to-production-4/#whats-next","title":"What\u2019s next","text":"<p>We're diligently developing our upcoming features, with key objectives including:</p> <ol> <li>Numerically defining and organizing the strengths of relationships within graphs.</li> <li>Creating a structured data model with opinions to facilitate document structure and data extraction.</li> <li>Converting Cognee into a Python library for easier integration.</li> <li>Broadening our database compatibility to support a broader range of systems.</li> </ol> <p>Make sure to explore our implementation on GitHub, and, if you find it valuable, consider starring it to show your support.</p>"},{"location":"blog/posts/from-demo-to-production-4/#conclusion","title":"Conclusion","text":"<p>If you enjoy the content or want to try out <code>cognee</code> please check out the github and give us a star!</p>"},{"location":"concepts/graph_data_models/","title":"Data models","text":"<p>Graph data models are fundamental structures used to represent and store data in the form of graphs, which consist of nodes (or vertices) and edges (or links). This model is particularly effective for illustrating relationships and connections among various data entities, making it invaluable in domains such as social networks, recommendation systems, logistics, biological networks, and more. Here's an overview of key concepts and types of graph data models:</p> <p>Key Concepts: Nodes (Vertices): Represent entities or objects within the graph, such as people in a social network, stations in a transportation map, or proteins in biological networks. Edges (Links): Depict the relationships or interactions between nodes. Edges can be directed (indicating a one-way relationship) or undirected (indicating a mutual relationship). Properties: Both nodes and edges can have properties (key-value pairs) that provide additional information, such as weights, types, or other attributes relevant to the application.</p>"},{"location":"concepts/llm_structured_outputs/","title":"LLM structured Outputs","text":"<p>Function calling in the context of Large Language Models (LLMs) like GPT-3, GPT-4, and their derivatives extends beyond traditional programming paradigms. In this scenario, function calling involves prompting the LLM to simulate the behavior of a function within its generated output. This capability allows users to interact with LLMs in a structured way, effectively requesting specific operations or information retrieval tasks by framing their prompts as function calls.</p> <p>How LLM Function Calling Works: Prompt Construction: The user constructs a prompt that mimics a function call in programming. This prompt includes the \"name\" of the function (often a description of the task) and the \"arguments\" (the specific inputs or conditions for the task). For example, a prompt might look like \"Generate a summary for the following article:\" followed by the article text.</p> <p>LLM Interpretation: The LLM interprets this structured prompt and understands it as a request to perform a specific task, similar to how a function in a program would be invoked. The model then generates an output that aligns with the expected behavior of the function described in the prompt.</p> <p>Parameters and Outputs: In LLM function calling, the parameters are the details provided in the prompt, and the output is the generated text that the model produces in response. This output is intended to fulfill the function's \"purpose\" as inferred from the prompt.</p>"},{"location":"concepts/multilayer_graph_networks/","title":"Multilayer graph network","text":"<p>A multilayer graph network is a sophisticated structure used to model complex systems where entities and their interactions can exist in multiple layers, each representing a different type of relationship, context, or domain. Unlike traditional graphs that capture connections in a single, uniform setting, multilayer graphs provide a more nuanced framework, allowing for the representation of diverse interconnections and dependencies across various dimensions or layers. </p>"},{"location":"concepts/propositions/","title":"Propositions","text":"<p>Propositions are fundamental elements in the study of logic, linguistics, and natural language processing. They represent atomic expressions within texts that encapsulate distinct factoids, conveying specific pieces of information. In essence, a proposition is a declarative statement that can either be true or false, but not both simultaneously. This binary nature makes propositions crucial for logical deductions, reasoning, and the construction of arguments.</p> <p>In a natural language context, propositions are presented in a concise and self-contained format.  They are designed to convey information clearly and unambiguously, making them easily interpretable by humans and computable by machines. For example, the statement \"The Eiffel Tower is in Paris\" is a proposition because it presents a specific fact about the location of the Eiffel Tower, and its truth value can be assessed as either true or false.</p> <p>The concept of propositions extends beyond mere statements of fact to include assertions about concepts, relationships, and conditions.  For instance, \"If it rains, the ground gets wet\" is a conditional proposition that establishes a cause-and-effect relationship between two events.</p> <p>In computational linguistics and natural language processing, propositions are vital for tasks such as information extraction, knowledge representation, and question answering.</p>"}]}